{
  "_args": [
    [
      "indicative@https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
      "/media/tengex/Storage1/Egyetem/16-17-1/ALKG/alkfejl"
    ]
  ],
  "_from": "indicative@>=2.1.1 <3.0.0",
  "_id": "indicative@2.1.2",
  "_inCache": true,
  "_location": "/indicative",
  "_phantomChildren": {
    "asap": "2.0.4",
    "pop-iterate": "1.0.1",
    "weak-map": "1.0.5"
  },
  "_requested": {
    "name": "indicative",
    "raw": "indicative@https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
    "rawSpec": "https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/adonis-validation-provider"
  ],
  "_resolved": "https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
  "_shasum": "43776b7d4bac79301bd9cedeeafa480d11b2f017",
  "_shrinkwrap": null,
  "_spec": "indicative@https://registry.npmjs.org/indicative/-/indicative-2.1.2.tgz",
  "_where": "/media/tengex/Storage1/Egyetem/16-17-1/ALKG/alkfejl",
  "author": {
    "name": "amanvirk"
  },
  "bugs": {
    "url": "https://github.com/poppinss/indicative/issues"
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  },
  "dependencies": {
    "inflect": "^0.3.0",
    "lodash": "^4.12.0",
    "moment": "^2.13.0",
    "pope": "^1.0.0",
    "q": "^2.0.3"
  },
  "description": "Intentionally beautiful schema and raw validator for nodejs",
  "devDependencies": {
    "benchmark": "^2.1.0",
    "chai": "^3.5.0",
    "co-mocha": "^1.1.2",
    "coveralls": "^2.11.9",
    "cz-conventional-changelog": "^1.1.6",
    "istanbul": "^0.4.3",
    "mocha": "^2.4.5",
    "mocha-lcov-reporter": "^1.2.0",
    "standard": "^7.1.0"
  },
  "directories": {
    "doc": "docs",
    "test": "test"
  },
  "homepage": "https://github.com/poppinss/indicative#readme",
  "keywords": [
    "node-validator",
    "quick-validations",
    "schema-validator",
    "validator"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "indicative",
  "optionalDependencies": {},
  "readme": "# Indicative\n\nIndicative is an expressive Javascript validator for humans. Improve your workflow by removing all unnecessary curly braces and nested declarations. Under the hood indicative has following.\n\n * Schema validator to validate an data object.\n * It has support for nested validations.\n * Custom messages for validations and rules.\n * Raw validator for quick `if` validations\n * Data Sanitization\n * Return promises\n * Es6 generators friendly.\n\n![build](https://img.shields.io/travis/poppinss/indicative.svg?style=flat-square)\n[![Coverage Status](https://img.shields.io/coveralls/poppinss/indicative/master.svg?style=flat-square)](https://coveralls.io/github/poppinss/indicative?branch=master)\n[![Version](https://img.shields.io/npm/v/indicative.svg?style=flat-square)](https://www.npmjs.com/package/indicative)\n[![Downloads](https://img.shields.io/npm/dt/indicative.svg?style=flat-square)](https://www.npmjs.com/package/indicative)\n[![License](https://img.shields.io/npm/l/indicative.svg?style=flat-square)](https://opensource.org/licenses/MIT)\n\n## Installation\n\nInstalling indicative requires node 4.0 or greater with npm installed.\n\n```javascript\nnpm i --save indicative\n```\n\n## Basics\n\nIndicative is an expressive schema/raw validator for NodeJs and offers clean syntax over snake of curly braces.To validate an object of data, you need to define a schema where each field can have multiple rules.\n\n### Setup\n\nYou start by requiring indicative and then make use of multiple methods to validate a data object with schema definition.\n\n```javascript\nconst indicative = require('indicative')\n```\n\n#### validate (data, rules, [messages])\nValidate method will run the validation cycle, which gets terminated on the first error.\n\n```javascript\n\nconst rules = {\n  username: 'required'\n}\n\nconst data = {\n  username: null\n}\n\nindicative\n.validate(data, rules)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\n#### validateAll (data, rules, [messages])\nValidate all will validate all fields even after errors are thrown and return an array of error messages.\n\n```javascript\nindicative.validateAll(data, rules)\n```\n\n### Rules\n\nIndicative helps you in defining rules as a string, which makes it more readable and remove unnecessary curly braces from your schema definition.\n\nA rule is a combination of certain logical expression that are parsed by a parser before starting validation.\n\n1. **|** - A pipe symbol ( | ) is used to define multiple rules\n2. **:** - A colon ( : ) is used to define values next to your rules\n3. **,** - And a comma ( , ) is used to define multiple values next to your rules.\n\n#### basic rule\nA basic rule may look like this, where we define multiple rules by separating them with a pipe symbol.\n\n```javascript\n{\n  email_address: 'required|email'\n}\n```\n\n#### rule with values\nA complex rule can have values defined next to rule definition, which later will be used to run validations.\n\n```javascript\n{\n  age: 'required|above:18'\n}\n```\n\nDefine age is separated by the colon on `above` rule. Also, some rules can accept multiple values next to a given rule.\n\n```javascript\n{\n  age: 'required|range:18,40'\n}\n```\n\n### Schema\n\nSchema definition is an object containing multiple rules for multiple fields and is used by validation methods.\n\n```javascript\nconst rules = {\n  username  : 'required|alpha_numeric',\n  email     : 'required|email',\n  password  : 'required|min:6|max:30'\n}\n```\n\nSchema object is a set of different rules defined for different fields and in order to validate an object of data you need to pass `rules` and `data` together to `validate` method.\n\n```javascript\nconst rules = {\n  username  : 'required|alpha_numeric',\n  email     : 'required|email',\n  password  : 'required|min:6|max:30'\n}\n\nconst data = {\n  username  : 'doe22',\n  email     : 'doe@example.org',\n  password  : 'doe123456'\n}\n\nindicative\n.validate(data, rules)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\n#### nested rules\n\nIn order to validate nested data you need to make use of `dot-notation` to target nested fields inside data object.\n\n```javascript\nconst rules = {\n  'profile.username'  : 'required',\n  'profile.password'  : 'required|min:6|max:30'\n}\n\nconst data = {\n  profile:{\n    username  : 'doe22',\n    password  : 'doe123456'\n  }\n}\n```\n\nHere `dot-notation` will help you in removing the use of unnecessary curly braces and can target nested data to any given number of levels.\n\n### Custom messages\n\nIndicative self-constructs error messages when validation for a given rule fails, which may not be helpful when trying to keep error messages descriptive and personalised.\n\n#### global messages\nGlobal messages are defined on rules, and the same message will be used whenever a rule will fail.\n\n```javascript\nconst messages = {\n  required: 'This field is required to complete the registration process.'\n}\n\nindicative\n.validate(data, rules, messages)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\nWhenever a `required` rule fails, it will return your custom message instead of a self-constructed message.\n\n#### field specific messages.\n`field` specific messages are even more personalised as they are defined for a given rule and field.\n\n```javascript\nconst messages = {\n  'username.required' : 'Username is required to continue',\n  'email.required'    : 'Email is required for further communication'\n}\n\n\nindicative\n.validate(data, rules, messages)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\nAlso, you can make use of `dot-notation` while defining messages.\n\n```javascript\nconst messages = {\n  'profile.username.required': 'Username is required to setup profile'\n}\n```\n\n#### getters\ninstead of defining a string as a message, you can also define a function to return message\n\n```javascript\nconst messages = {\n  'username.required': function (field, validation, args) {\n    return `${field} is required`\n  }\n}\n```\n\n\n### Templating\nAll custom messages support templating, which means you can define special placeholders that will be replaced with actual values while constructing messages.\n\n#### field\n`field` is the name of the field under validation\n\n```javascript\nconst messages = {\n  required: '{{field}} is required to complete registeration process'\n}\n```\n\n#### validation\nName of the validation rule.\n\n```javascript\nconst messages = {\n  email: '{{validation}} validation failed on {{field}}.'\n}\n\nconst data = {\n  email: 'abc'\n}\n```\n\n#### argument\n`arguments` are values defined on rules inside schema, and they can be accessed using their array index.\n\n```javascript\nconst messages = {\n  above: '{{field}} must be over {{argument.0}} years'\n}\n\nconst rules = {\n  age: 'above:18'\n}\n\nconst data = {\n  age: 10\n}\n\n```\n\nAbove message will yield `age must be over 18 years`.\n\n### Array Expressions\n\nValidating arrays asynchronously is never fun. Indicative makes it so simple to validating one level deep nested arrays using `array expressions`.\n\n```javascript\nconst rules = {\n  'users.*.username': 'required|alpha',\n  'users.*.email': 'required|email'\n}\n\nconst data = {\n  users: [\n    {\n      username: 'validUsername',\n      email: 'bar.sneark@gmail.com'\n    },\n    {\n      username: '123Invalid',\n      email: 'bar.com'\n    }\n  ]\n}\n\nindicative\n.validate(data, rules)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\nAlso you can validate flat arrays using the same expression syntax.\n\n```javascript\nconst rules = {\n  'emails': 'array|min:2', \n  'emails.*': 'email'\n}\n\nconst data = {\n  emails: ['foo@bar.com', 'invalid.com']\n}\n\nindicative\n.validate(data, rules)\n.then(function () {\n  // validation passed\n})\n.catch(function (errors) {\n  // validation failed\n})\n```\n\n## Sanitizor\n\nFirst rule of developing applications is to keep your datastores clean. Indicative sanitizor will help you in normalizing data by using set of specific rules.\n\n### Using Schema\nLike validations you can use a schema object to sanitize our data object.\n\n```javascript\nconst indicative = require('indicative')\n\nconst data = {\n  email: 'bar.sneaky+foo@googlemail.com',\n  age: '22',\n  aboutme: 'i am dev @<a href=\"http://nowhere.com\">nowhere</a>'\n}\n\nconst sanitizationRules = {\n  email: 'normalize_email',\n  age: 'to_int',\n  aboutme: 'strip_links'\n}\n\nconst sanitizedData = indicative.sanitize(data, sanitizationRules)\nconsole.log(sanitizedData)\n\n/**\n {\n  email: 'barsneaky@gmail.com',\n  age: 22,\n  aboutme: 'i am dev @nowhere'\n }\n */\n\n```\n\n### Raw Sanitizor\nFor quick sanitizations you can make use of raw filters\n\n```javascript\nconst indicative = require('indicative')\nindicative.sanitizor.toInt('22') // 22\nindicative.sanitizor.slug('hello world') // hello-world\nindicative.sanitizor.toDate('22-1-2016') // javascript date object\n```\n\n### Filters\nBelow is the list of filters available to be used for raw and schema sanitizations.\n\n#### blacklist <span class=\"italic\">(values)</span>\nremoves values inside blacklist from the actual string. Passed values are used inside a regex, so make sure to escape values properly. `\\\\[\\\\]` instead of `\\`.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.blacklist('hello world', 'ord')\n\n// with schema\n{\n  description: 'blacklist:ord'\n}\n```\n\n#### escape\nEscapes html characters with html entities\n```javascript\n// raw sanitization\nindicative.sanitizor.escape('<div> hello world </div>')\n\n// with schema\n{\n  description: 'escape'\n}\n```\n\n#### normalizeEmail <span class=\"italic\">(options)</span>\nNormalizes email and accepts options to avoid certains transformations.\n\n1. **!lc** - Do not convert email to lowercase, hence domain name will be converted to lowercase. `FOO@GMAIL.COM` will become `FOO@gmail.com`\n\n2. **!rd** - Stop sanitizor from removing dots.\n3. **!re** - Do not remove everything after `+` symbol. `bar.sneaky+foo@gmail.com` will become `barsneaky+foo@gmail.com`\n\n```javascript\n// raw sanitization\nindicative.sanitizor.normalizeEmail('bar.sneaky+foo@gmail.com', ['!rd', '!re', '!lc'])\n\n// with schema\n{\n  email: 'normalize_email:!rd,!re,!lc'\n}\n```\n\n#### toBoolean\nConverts value to a boolean, `0, false, null, undefined, ''` will return `false` and everything else will return `true`.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.toBoolean('false')\n\n// with schema\n{\n  isAdmin: 'to_boolean'\n}\n```\n\n#### toFloat\nConverts value to float and returns `NaN` if unable to convert.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.toFloat('32.55')\n\n// with schema\n{\n  marks: 'to_float'\n}\n```\n\n#### toInt\nConverts value to integer and returns `NaN` if unable to convert.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.toInt('32')\n\n// with schema\n{\n  age: 'to_int'\n}\n```\n\n#### toInt\nConverts value to date object and returns `null` if unable to convert.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.toDate('2010-22-10')\n\n// with schema\n{\n  age: 'to_date'\n}\n```\n\n#### stripLinks\nStrips `<a></a>` tags from a given string. If input is not a string, actual value will be returned.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.stripLinks('<a href=\"http://adonisjs.com\"> Adonisjs </a>')\n\n// with schema\n{\n  bio: 'strip_links'\n}\n```\n\n#### stripTags\nStrips html tags from a given string. If input is not a string, actual value will be returned.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.stripTags('<p> Hello </p>')\n\n// with schema\n{\n  tweet: 'strip_tags'\n}\n```\n\n#### plural\nConverts a given value to plural. Which means `person` will be converted to `people`.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.plural('child')\n\n// with schema\n{\n  november14: 'plural'\n}\n```\n\n#### singular\nConverts a given value to singular. Which means `people` will be converted to `person`.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.plural('children')\n\n// with schema\n{\n  november14: 'singular'\n}\n```\n\n#### camelCase\nConverts a given to camel-case.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.camelCase('users-controller')\n\n// with schema\n{\n  fileName: 'camel_case'\n}\n```\n\n#### capitalize\n`capitalize` a given string.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.capitalize('doe')\n\n// with schema\n{\n  fullName: 'capitalize'\n}\n```\n\n#### decapitalize\n`decapitalize` a given string.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.decapitalize('Bar')\n\n// with schema\n{\n  username: 'decapitalize'\n}\n```\n\n#### title\nconverts a value to title case\n\n```javascript\n// raw sanitization\nindicative.sanitizor.title('hello-world')\n\n// with schema\n{\n  title: 'title'\n}\n```\n\n#### slug\nConverts a value to url friendly slug.\n\n```javascript\n// raw sanitization\nindicative.sanitizor.slug('learn node in 30 minutes')\n\n// with schema\n{\n  title: 'slug'\n}\n```\n\n## Extending\n\nIndicative ships with a handful of validation rules, which may or may not be enough for your application that's why it is so easy to extend schema or raw validator to register your custom rules.\n\n### Extending Schema Validator\nExtending Schema validator will register your custom rule to validations store and should follow defined convention, where all rules are registered as `camelCase` and consumed as `snake_case`.\n\nFor example, indicative's `alpha_numeric` rule is defined as `alphaNumeric` inside validation store.\n\n#### validation method\nValidation method supports `async` execution and should return a promise. `Async` execution makes is easier for you to write database driven rules. For example `unique` rule to check if the username already exists or not.\n\n```javascript\nconst unique = function (data, field, message, args, get) {\n\n  return new Promise(function (resolve, reject) {\n\n    // get value of field under validation\n    const fieldValue = get(data, field)\n\n    // resolve if value does not exists, value existence\n    // should be taken care by required rule.\n    if(!fieldValue) {\n      return resolve('validation skipped')\n    }\n\n    // checking for username inside database\n    User\n    .where('username', fieldValue)\n    .then(function (result) {\n      if(result){\n        reject(message)\n      }else{\n        resolve('username does not exists')\n      }\n    })\n    .catch(resolve)\n\n  })\n\n}\n```\n\nAbove we defined a method to check for a unique username inside the database, validation method can keep any logic to validate data but you should know about method parameters to make valid decisions.\n\n1. **data** - It is the actual data object passed to `validate` method.\n2. **field** - Field is a string value of field under validation.\n3. **message** - Error message to return.\n4. **args** - An array of values your rule is expecting, it may be empty depending upon your rule expectations. For example `min:4` will have args array as `[4]`.\n5. **get** - it is a special function to get value for a given key from the data object, it is recommended to make use of this function as getting nested values from an object can be a tedious task and `get` method takes care of it.\n\n#### extend\nOnce you have defined your validation method, you can add it to validations store by calling `extend` method.\n\n```javascript\nindicative.extend('unique', unique, 'Field should be unique')\n```\n\nExtend method takes 3 required parameters to register validation to validations store.\n\n1. **name** - remember to define name as `camelCase` which is consumed as `snake_case`.\n2. **method** - validation method to be executed.\n3. **message** - the error message to print on validation failure.\n\nOnce your custom validation rule has been stored, you can consume it inside your schema.\n\n```javascript\nconst rules = {\n  username: 'required|unique'\n}\n```\n\n### Extending Raw Validator\nExtending raw validator is fairly simple as raw validations are quick validations. An example of raw validation can be\n\n```javascript\nindicative.is.email('your@youremail.com')\n```\n\nAnd to extend raw validator you need to define a validation method that can accept `n` number of arguments based on validation expectations. A good example of raw validation can be a password strength checker\n\n```javascript\nconst strongPassword = function (password) {\n  const strongRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\\$%\\^&\\*])(?=.{8,})/\n  return strongRegex.test(password)\n}\n```\n\nAbove we created a function to check whether a password is strong enough or not, and now we can register it is a raw validator.\n\n```javascript\nindicative.is.extend('strongPassword', strongPassword)\n```\n\n`is.extend` accepts two parameters where the first one is the method name and second is validation method to execute. Finally, you can use this method as follows.\n\n```javascript\nindicative.is.strongPassword('lowerUPP@123')\n// returns true\n```\n\n### Extending Sanitizor\nYou can also extend sanitizor to add more filters to it. All extended methods will get the value to sanitize, with an array of options.\n\n```javascript\nconst uppercase = function (value, options: Array) {\n  return value.toUpperCase()\n}\n```\n\nAbove we created a simple method to return `Uppercase` version of a string. Now we will added to the list of sanitizor filters, so that we can use it later.\n\n```javascript\nindicative.sanitizor.extend('uppercase', uppercase)\n```\n\nNow finally you can use it.\n\n```javascript\n// raw sanitizor\nindicative.sanitizor.uppercase('hello world')\n\n// with schema\n{\n  userStatus: 'uppercase'\n}\n```\n\n## Raw Validations\n\nBelow is the list of methods supported by the raw validator, also you can [extend raw validator](#indicative-extending-extending-raw-validator) to add your rules.\n\n### Types\n\nTypes based validations will check for a certain type\n\n#### array <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.array({age:22})\n=> false\n\nindicative.is.array('hello world')\n=> false\n\nindicative.is.array([20,22])\n=> true\n\nindicative.is.array([])\n=> true\n```\n\n#### boolean <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.boolean('true')\n=> false\n\nindicative.is.boolean('hello')\n=> false\n\nindicative.is.boolean(0)\n=> true\n\nindicative.is.boolean(1)\n=> true\n\nindicative.is.boolean(true)\n=> true\n\nindicative.is.boolean(false)\n=> true\n```\n\n#### date <span class=\"italic\">(value [, strict])</span>\nstrict `true` will only return true when a date object is passed.\n\n```javascript\nindicative.is.date('2011-10-20')\n=> true\n\nindicative.is.date('2011-10-20', true)\n=> false\n\nindicative.is.date(new Date('2011-10-20'))\n=> true\n\nindicative.is.date(new Date('2011-10-20'), true)\n=> true\n```\n\n#### function <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.function(function () {})\n=> true\n\nindicative.is.function('function () {}')\n=> false\n```\n\n#### null <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.null(null)\n=> true\n\nindicative.is.null('null')\n=> false\n```\n\n#### number <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.number(22)\n=> true\n\nindicative.is.number('22')\n=> false\n```\n\n#### object <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.object({name:'doe'})\n=> true\n\nindicative.is.object(['doe'])\n=> false\n\nindicative.is.object('doe')\n=> false\n\nindicative.is.object({})\n=> true\n```\n\n#### json <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.json(JSON.stringify({name:'doe'}))\n=> true\n\nindicative.is.json(JSON.stringify([10,20]))\n=> true\n\nindicative.is.json({name:'doe'})\n=> false\n```\n\n#### string <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.string(JSON.stringify({name:'doe'}))\n=> true\n\nindicative.is.string('hello world')\n=> true\n\nindicative.is.string(22)\n=> false\n```\n\n#### sameType <span class=\"italic\">(value, comparisonValue)</span>\n\n```javascript\nindicative.is.sameType(22,10)\n=> true\n\nindicative.is.sameType('hello', 'world')\n=> true\n\nindicative.is.sameType(22, '10')\n=> false\n```\n\n### Presence\n\n#### existy <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.existy('')\n=> false\n\nindicative.is.existy(null)\n=> false\n\nindicative.is.existy(undefined)\n=> false\n\nindicative.is.existy('hello')\n=> true\n\nindicative.is.existy(22)\n=> true\n```\n\n#### truthy <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.truthy(false)\n=> false\n\nindicative.is.truthy(0)\n=> false\n\nindicative.is.truthy(true)\n=> true\n\nindicative.is.truthy('hello')\n=> true\n```\n\n#### falsy <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.falsy(false)\n=> true\n\nindicative.is.falsy(0)\n=> true\n\nindicative.is.falsy(true)\n=> false\n\nindicative.is.falsy('hello')\n=> false\n```\n\n#### empty <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.empty(null)\n=> true\n\nindicative.is.empty(undefined)\n=> true\n\nindicative.is.empty({})\n=> true\n\nindicative.is.empty([])\n=> true\n\nindicative.is.empty('')\n=> true\n\nindicative.is.empty('hello')\n=> false\n\nindicative.is.empty(0)\n=> false\n```\n\n### Regex\n\n#### url <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.url('http://adonisjs.com')\n=> true\n\nindicative.is.url('https://adonisjs.com')\n=> true\n\nindicative.is.url('adonisjs.com')\n=> false\n\nindicative.is.url('adonisjs')\n=> false\n```\n\n#### email <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.email('email@example.org')\n=> true\n\nindicative.is.url('email.org')\n=> false\n```\n\n#### phone <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.phone('1235554567')\n=> true\n\nindicative.is.phone('444-555-1234')\n=> true\n\nindicative.is.phone('246.555.8888')\n=> true\n\nindicative.is.phone('19929')\n=> false\n```\n\n#### creditCard <span class=\"italic\">(value)</span>\n\nsupports **Visa,MasterCard,American Express,Diners Club,Discover,JCB**\n\n```javascript\nindicative.is.creditCard('4444-4444-4444-4444')\n=> true\n\nindicative.is.creditCard('4444444444444444')\n=> true\n\nindicative.is.creditCard('3685-1600-4490-1023')\n=> false\n```\n\n#### alpha <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.alpha('virk')\n=> true\n\nindicative.is.alpha('VIrk')\n=> true\n\nindicative.is.alpha('virk123')\n=> false\n```\n\n#### alphaNumeric <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.alphaNumeric('virk')\n=> true\n\nindicative.is.alphaNumeric('virk123')\n=> true\n\nindicative.is.alphaNumeric('virk@123')\n=> false\n```\n\n#### ip <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.ip('127.0.0.1')\n=> true\n\nindicative.is.ip('192.168.0.1')\n=> true\n\nindicative.is.ip('1:2:3:4:5:6:7:8')\n=> true\n\nindicative.is.ip('localhost')\n=> false\n```\n\n#### ipv4 <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.ipv4('127.0.0.1')\n=> true\n\nindicative.is.ipv4('192.168.0.1')\n=> true\n\nindicative.is.ipv4('1:2:3:4:5:6:7:8')\n=> false\n```\n\n#### ipv6 <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.ipv6('985.12.3.4')\n=> true\n\nindicative.is.ipv6('1:2:3:4:5:6:7:8')\n=> true\n\nindicative.is.ipv6('1.2.3')\n=> false\n```\n\n#### regex <span class=\"italic\">(pattern, value)</span>\nrun your own custom regex\n\n```javascript\nindicative.is.regex(/[a-z]+/,'virk')\n=> true\n\nindicative.is.regex(/[a-z]+/,'virk123')\n=> false\n```\n\n### Arithmetic\n\n#### same <span class=\"italic\">(value, comparisonValue)</span>\n\n```javascript\nindicative.is.same(10,5+5)\n=> true\n\nindicative.is.same('hello','hello')\n=> true\n\nindicative.is.same('10',10)\n=> false\n```\n\n#### even <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.even(10)\n=> true\n\nindicative.is.even(5)\n=> false\n```\n\n#### odd <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.odd(10)\n=> false\n\nindicative.is.odd(5)\n=> true\n```\n\n#### positive <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.positive(10)\n=> true\n\nindicative.is.positive(-10)\n=> false\n```\n\n#### negative <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.negative(10)\n=> false\n\nindicative.is.negative(-10)\n=> true\n```\n\n#### above <span class=\"italic\">(value, comparisonValue)</span>\n\n```javascript\nindicative.is.above(10, 20)\n=> false\n\nindicative.is.above(30,20)\n=> true\n```\n\n#### under <span class=\"italic\">(value, comparisonValue)</span>\n\n```javascript\nindicative.is.under(30, 20)\n=> false\n\nindicative.is.under(10,20)\n=> true\n```\n\n#### between <span class=\"italic\">(value, min, max)</span>\n\n```javascript\nindicative.is.between(20,10,30)\n=> true\n\nindicative.is.between(5,10,30)\n=> false\n```\n\n### Array\n\n#### inArray <span class=\"italic\">(value, comparsionArray)</span>\n\n```javascript\nindicative.is.inArray(10,[10,20,40])\n=> true\n\nindicative.is.inArray(5,[10,20,40])\n=> false\n```\n\n#### sorted <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.sorted([10,20,40,50])\n=> true\n\nindicative.is.sorted([10,15,5,20])\n=> false\n```\n\n#### intersectAny <span class=\"italic\">(value, comparisonArray)</span>\n\n```javascript\nindicative.is.intersectAny([10,20],[30,10,40])\n=> true\n\nindicative.is.intersectAny([10,20],[30,50,40])\n=> false\n```\n\n#### intersectAll <span class=\"italic\">(value, intersectAll)</span>\n\n```javascript\nindicative.is.intersectAll([10,20],[20,10,50,40])\n=> true\n\nindicative.is.intersectAll([10,20],[10,50,40])\n=> false\n```\n\n### Dates\n\n#### today <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.today(new Date())\n=> true\n\n// if today date is 2015-11-30\nindicative.is.today(\"2015-11-30\")\n=> true\n\nconst yesterday = new Date(new Date().setDate(new Date().getDate() - 1))\nindicative.is.today(yesterday)\n=> false\n```\n\n#### yesterday <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.yesterday(new Date())\n=> false\n\n// if yesterday date was 2015-11-29\nindicative.is.yesterday(\"2015-11-29\")\n=> true\n\nconst yesterday = new Date(new Date().setDate(new Date().getDate() - 1))\nindicative.is.yesterday(yesterday)\n=> true\n```\n\n#### tomorrow <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.tomorrow(new Date())\n=> false\n\n// if tomorrow date will be 2015-12-01\nindicative.is.tomorrow(\"2015-12-01\")\n=> true\n\nconst tomorrow = new Date(new Date().setDate(new Date().getDate() + 1))\nindicative.is.tomorrow(tomorrow)\n=> true\n```\n\n#### past <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.past(\"2001-01-10\")\n=> true\n\nconst tomorrow = new Date(new Date().setDate(new Date().getDate() + 1))\nindicative.is.past(tomorrow)\n=> false\n```\n\n#### future <span class=\"italic\">(value)</span>\n\n```javascript\nindicative.is.future(\"2001-01-10\")\n=> false\n\nconst tomorrow = new Date(new Date().setDate(new Date().getDate() + 1))\nindicative.is.future(tomorrow)\n=> true\n```\n\n#### after <span class=\"italic\">(value, afterDate)</span>\n\n```javascript\nindicative.is.after(\"2015-10-01\", \"2015-10-03\")\n=> false\n\nindicative.is.after(\"2015-10-01\", \"2015-09-10\")\n=> true\n```\n\n#### before <span class=\"italic\">(value, beforeDate)</span>\n\n```javascript\nindicative.is.before(\"2015-10-01\", \"2015-10-03\")\n=> true\n\nindicative.is.before(\"2015-10-01\", \"2015-09-10\")\n=> false\n```\n\n#### dateFormat <span class=\"italic\">(value, formats)</span>\n\n```javascript\nindicative.is.dateFormat(\"2015-10-01\", ['YYYY-MM-DD'])\n=> true\n\nindicative.is.dateFormat(\"2015/10/01\", ['YYYY-MM-DD'])\n=> false\n\nindicative.is.dateFormat(\"2015/10/01\", ['YYYY-MM-DD', 'YYYY/MM/DD'])\n=> true\n```\n\n#### inDateRange <span class=\"italic\">(value, minDate, maxDate)</span>\n\n```javascript\nindicative.is.inDateRange(\"2015-10-01\", \"2015-09-01\", \"2015-12-01\")\n=> true\n\nindicative.is.inDateRange(\"2015-10-01\", \"2015-11-01\", \"2015-12-01\")\n=> false\n```\n\n## Schema Rules\n\nSchema rules can/may be different from raw validation rules. In order make use of schema validation rules you need to pass a schema object to indicative `validate` or `validateAll` method.\n\n```javascript\nconst indicative = require('indicative')\n\nconst rules = {\n  username : 'required|alpha_numeric|min:6|max:20',\n  email    : 'required|email'\n}\n\nindicative\n.validate(data, rules)\n.then (function () {\n  // validation passed\n})\n.catch(function () {\n  // validation failed\n})\n```\n<ul class=\"__columnized\">\n\n[above](#above)\n[accepted](#accepted)\n[after](#after)\n[after_offset_of](#after_offset_of)\n[alpha](#alpha)\n[alpha_numeric](#alpha-numeric)\n[array](#array)\n[before](#before)\n[before_offset_of](#before_offset_of)\n[boolean](#boolean)\n[date](#date)\n[date_format](#date-format)\n[different](#different)\n[email](#email)\n[ends_with](#ends-with)\n[equals](#equals)\n[in](#in)\n[includes](#includes)\n[integer](#integer)\n[ip](#ip)\n[ipv4](#ipv4)\n[ipv6](#ipv6)\n[json](#json)\n[max](#max)\n[min](#min)\n[not_equals](#not-equals)\n[not_in](#not-in)\n[object](#object)\n[range](#range)\n[regex](#regex)\n[required](#required)\n[required_if](#required-if)\n[required_when](#required-when)\n[required_with_all](#required-with-all)\n[required_with_any](#required-with-any)\n[required_without_all](#required-without-all)\n[required_without_any](#required-without-any)\n[same](#same)\n[starts_with](#starts-with)\n[under](#under)\n[url](#url)\n\n</ul>\n\n#### above\nthe field under validation should be above defined value\n\n```javascript\n{\n  age : 'above:18'\n}\n```\n\n#### accepted\nfield should have been accepted with truthy value for ex - **yes,1,true**\n\n```javascript\n{\n  toc: 'accepted'\n}\n```\n\n#### after\nthe value of field should be after define date\n\n```javascript\n{\n  newyear_party: 'after:2015-12-24'\n}\n```\n\n#### after_offset_of\nthe value of field should be after defined offset from today's date\n\n```javascript\n{\n  expires: 'after_offset_of:12,months'\n}\n```\n\n#### alpha\nthe value of field should contain letters only\n\n```javascript\n{\n  name: 'alpha'\n}\n```\n\n#### alpha_numeric\nthe value of field should contain letters and numbers only\n\n```javascript\n{\n  username: 'alpha_numeric'\n}\n```\n\n#### array\nthe value should be an array\n\n```javascript\n{\n  permissions : 'array'\n}\n```\n\n#### before\nthe value of field should be before define date\n\n```javascript\n{\n  file_tax: 'before:2015-03-31'\n}\n```\n\n#### before_offset_of\nthe value of field should be before defined offset from today's date\n\n```javascript\n{\n  enrollment: 'before_offset_of:1,year'\n}\n```\n\n#### boolean\nvalue of field should contain a boolean value, **true,false,0,1,'0','1'** will yield true\n\n```javascript\n{\n  is_admin: 'boolean'\n}\n```\n\n#### date\nthe value of field should be a valid date, **MM/DD/YYYY, MM-DD-YYYY, YYYY-MM-DD, YYYY/MM/DD** formats\nare allowed\n\n```javascript\n{\n  published_on: 'date'\n}\n```\n\n#### date_format\nthe value of field should be a valid date according to given format\n\n```javascript\n{\n  published_on: 'date_format:YYYY-MM-DD'\n}\n```\n\n#### different\nthe value of 2 fields should be different\n\n```javascript\n{\n  alternate_email: 'different:email'\n}\n```\n\n#### email\nshould be a valid email address\n\n```javascript\n{\n  email_address: 'email'\n}\n```\n\n#### ends_with\nthe string should end with given letters\n\n```javascript\n{\n  domain: 'ends_with:.com'\n}\n```\n\n#### equals\nthe value of field under validation should equal the defined value\n\n```javascript\n{\n  age: 'equals:26'\n}\n```\n\n#### in\nthe value of field should fall within defined values\n\n```javascript\n{\n  gender: 'in:Male,Female,Other'\n}\n```\n\n#### includes\nthe value of field should include define letters\n\n```javascript\n{\n  sub_domain: 'includes:adonisjs'\n}\n```\n\n#### integer\nthe value of field under validation should be an integer\n\n```javascript\n{\n  age: 'integer'\n}\n```\n\n#### ip\nthe value of field under validation should be a valid ip address\n\n```javascript\n{\n  ip_address: 'ip'\n}\n```\n\n#### ipv4\nthe value of field under validation should be a valid ipv4 address\n\n```javascript\n{\n  ip_address: 'ipv4'\n}\n```\n\n#### ipv6\nthe value of field under validation should be a valid ipv6 address\n\n```javascript\n{\n  ip_address: 'ipv6'\n}\n```\n\n#### json\nvalue of field is safe for `JSON.parse`\n\n```javascript\n{\n  meta_data: 'json'\n}\n```\n\n#### max\nThe length of a given field should not be more than defined length. Numbers and strings are evaluated same way.\n\n```javascript\n{\n  password: 'max:20'\n}\n```\n\n#### min\nThe length of a given field should not be less than defined length. Numbers and strings are evaluated same way\n\n```javascript\n{\n  password: 'min:6'\n}\n```\n\n#### not_equals\nthe value of field under should be different from defined value\n\n```javascript\n{\n  username: 'not_equals:admin'\n}\n```\n\n#### not_in\nthe value of field under should not be one of the defined values.\n\n```javascript\n{\n  username: 'not_in:admin,super,root'\n}\n```\n\n#### object\nthe value of field should be a valid javascript object\n\n```javascript\n{\n  profile: 'object'\n}\n```\n\n#### range <span class=\"italic\">(alias:between)</span>\nvalue of field should be inside defined range, shorthand for min and max\n\n```javascript\n{\n  password: 'range:6,20'\n}\n```\n\n#### regex\nthe value of field under validation should satisfy regex pattern.\n\n<div class=\"note\">\n  <p>\n    <strong> Note : </strong> Always define rules as array when making use of regex rule\n  </p>\n</div>\n\n```javascript\n{\n  username: ['regex:^[a-zA-z]+$']\n}\n```\n\n#### required\nthe field should exist and contain some value\n\n```javascript\n{\n  username: 'required'\n}\n```\n\n#### required_if\nthe field is required when defined field exists\n\n```javascript\n{\n  password_confirmation: 'required_if:password'\n}\n```\n\n#### required_when\nthe field is required when value of defined field is same as defined value\n\n```javascript\n{\n  state: 'required_when:country,US'\n}\n```\n\n#### required_with_all\nthe field is required when all other fields are present\n\n```javascript\n{\n  social_geek: 'required_with_all:twitter,facebook,tumblr'\n}\n```\n\n#### required_with_any\nthe field is required when any of the other fields are present\n\n```javascript\n{\n  social_login: 'required_with_any:facebook_token,twitter_token'\n}\n```\n\n#### required_without_all\nthe field is required when all of the other fields does not exist\n\n```javascript\n{\n  rent: 'required_without_all:onwer,buyer'\n}\n```\n\n#### required_without_any\nthe field is required when any of the other fields does not exist\n\n```javascript\n{\n  sell: 'required_without_any:onwer,buyer'\n}\n```\n\n#### same\nthe value of field should be same as the value of define field\n\n```javascript\n{\n  password_confirm: 'same:password'\n}\n```\n\n#### starts_with\nthe value of field should start with defined letters\n\n```javascript\n{\n  accepted: 'starts_with:y'\n}\n```\n\n#### under\nthe value of field should be under defined value\n\n```javascript\n{\n  age: 'under:60'\n}\n```\n\n#### url\nthe value of field should be a valid url\n\n```javascript\n{\n  blog: 'url'\n}\n```\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/poppinss/indicative.git"
  },
  "scripts": {
    "coverage": "istanbul cover _mocha test --bail",
    "standard": "standard src/**/*.js",
    "test": "istanbul cover _mocha --report lcovonly -- -R spec test && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage"
  },
  "version": "2.1.2"
}
