{
  "_args": [
    [
      "co-functional@https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
      "/media/tengex/Storage1/Egyetem/16-17-1/ALKG/alkfejl"
    ]
  ],
  "_from": "co-functional@>=0.2.1 <0.3.0",
  "_id": "co-functional@0.2.1",
  "_inCache": true,
  "_location": "/co-functional",
  "_phantomChildren": {},
  "_requested": {
    "name": "co-functional",
    "raw": "co-functional@https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
    "rawSpec": "https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/adonis-auth",
    "/adonis-lucid"
  ],
  "_resolved": "https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
  "_shasum": "4238035db8b47aa72b8c85681bd913b86c86f5ed",
  "_shrinkwrap": null,
  "_spec": "co-functional@https://registry.npmjs.org/co-functional/-/co-functional-0.2.1.tgz",
  "_where": "/media/tengex/Storage1/Egyetem/16-17-1/ALKG/alkfejl",
  "author": {
    "email": "github@raeder.technology",
    "name": "Benjamin RÃ¤der"
  },
  "browserify": {
    "transform": [
      [
        "babelify",
        {
          "presets": [
            "es2015"
          ]
        }
      ]
    ]
  },
  "bugs": {
    "url": "https://github.com/N0ps32/co-functional/issues"
  },
  "dependencies": {
    "co": "^4.6.0",
    "lodash": "^4.0.0"
  },
  "description": "co-functional is a MIT licenced library that provides several functions for use with the [co](https://github.com/tj/co) library. Functions are curried (where possible) and are always iteratee-first, data last.",
  "devDependencies": {
    "chai": "^3.4.1",
    "chai-as-promised": "^5.2.0",
    "mocha": "^2.3.4"
  },
  "homepage": "https://github.com/N0ps32/co-functional#readme",
  "keywords": [
    "async",
    "co",
    "co bind",
    "co compose",
    "co filter",
    "co for",
    "co forEach",
    "co functional",
    "co reduce",
    "co-functional",
    "functional",
    "promise"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "co-functional",
  "optionalDependencies": {},
  "readme": "# co-functional\n\nco-functional is a MIT licenced library that provides several functions for use with the [co](https://github.com/tj/co)\nlibrary. Functions are curried (where possible) and are always iteratee-first, data last.\n\nCurrently the library provides the following functions:\n- [bind, lazyBind](#user-content-bind)\n- [compose](#user-content-compose)\n- [filter, filterSerial](#user-content-filter)\n- [forEach, forEachSerial](#user-content-for)\n- [map, mapSerial](#user-content-map)\n- [reduce](#user-content-reduce)\n\n## Installation\nYou can install co-functional using npm:\n```\nnpm install --save co-functional\n```\nThen you can require it in your code:\n```\nconst cf = require('co-functional');\n```\n\nBabelify transforms are defined in package.json.  \nSo you can also require co-functional in a browser in a non-ES2015 environment using browserify with babelify.\n\n## Functions\n\nNote that while in the following examples the returned Promises is handeled manually\nyou can of course yield the output of each function if you have a GeneratorFunction that is wrapped with co.\n\n###[<a name=\"bind\"></a>bind, lazyBind](#bind)\n\n**\"bind\"** binds the given function to the given context and executes it.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\"bind\" is curried so you may leave of the second parameter to delay execution.  \n```javascript\nconst promise = cf.bind(function* (argument) {\n    console.log(this); //scope that was bound\n    console.log(argument); //1234\n}, this, 1234).then(...);\n```\n\n**\"lazyBind\"** binds the given function to the given context and returns the bound function.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\"lazyBind\" is curried so you may leave of the second parameter to delay execution.  \n```javascript\nconst bound = cf.lazyBind(function* (argument) {\n    console.log(this); //scope that was bound\n    console.log(argument); //1234\n}, this);\n\nconst promise = bound(1234);\npromise.then(...);\n```\n\n###[<a name=\"compose\"></a>compose](#compose)\n\n**\"compose\"** composes the given functions right to left.  \nIf a function returns a promise the chain will wait for the promise to resolve and continue with the resolved value.  \nIf you pass a generator function as a function it will be wrapped with co and executed.  \nYou may pass multiple parameters to the first function but note that the following functions will only receive one value.\n```javascript\nconst composed = cf.compose(\n     function(n) {\n         console.log(n); //will log 3 to the console\n     },\n     function(n) {\n         return Promise.resolve(n + 1);\n     },\n     function* (n) {\n         return yield Promise.resolve(n + 1)\n     },\n     function(n) {\n         return n + 1;\n     }\n);\n\ncomposed(0).then(...).catch(...);\n```\n\n###[<a name=\"filter\"></a>filter, filterSerial](#filter)\n\n**\"filter\"** filters the given Array using the given generator function asynchronously.  \nThis function is curried so you may leave of the second parameter to delay execution.  \nIf the function returns a Promise the Promise will be resolved and the result will be used.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst asyncIsOddNumber = number => Promise.resolve(number % 2 === 0);\nconst promise = cf.filter(function* (number) {\n    return yield asyncIsOddNumber(number);\n}, [1, 2, 4]);\n\npromise.then(oddNumbers => {\n    console.log('All odd numbers: ', oddNumbers);\n});\n```\n\n**\"filterSerial\"** filters the given Array using the given generator function asynchronously but one after another.  \nIf you want the highest possible speed you should not use this function but the completely asynchronous filter function!  \nThat means your elements will get filtered in order and the function will wait until something\nhas been returned by your GeneratorFunction before continuing execution.\n\nThis function is curried so you may leave of the second parameter to delay execution.  \nIf the function returns a Promise the Promise will be resolved and the result will be used.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst asyncIsOddNumber = number => Promise.resolve(number % 2 === 0);\nconst promise = cf.filterSerial(function* (number) {\n    return yield asyncIsOddNumber(number);\n}, [1, 2, 4]);\n\npromise.then(oddNumbers => {\n    console.log('All odd numbers: ', oddNumbers);\n});\n```\n###[<a name=\"for\"></a>forEach, forEachSerial](#for)\n\n**\"forEach\"** loops over the given Array or Object asynchronously.  \nThis function is curried so you may leave of the second parameter to delay execution.  \nThe value is passed as the first, the key/index as the second parameter.  \nIf the function returns a Promise the Promise execution will halt until all Promises have been resolved.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst promise = cf.forEach(function* (data, index) {\n   console.log(data, index);\n}, [2, 4]);\n\nconst promise2 = cf.forEach(function* (data, key) {\n   console.log(data, key);\n}, { a: 2, b: 4});\n```\n\n**\"forEachSerial\"** loops over the given Array or Object asynchronously but one after another.  \nIf you want the highest possible speed you should not use this function but the completely asynchronous forEach function!  \nThat means your elements will get looped over in order and the function will wait until something  \nhas been returned by your function before continuing execution.\n\nThis function is curried so you may leave of the second parameter to delay execution.  \nThe value is passed as the first, the key/index as the second parameter.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst promise = cf.forEachSerial(function* (data, index) {\n   console.log(data, index);\n}, [2, 4]);\n\nconst promise2 = cf.forEachSerial(function* (data, key) {\n   console.log(data, key);\n}, { a: 2, b: 4});\n```\n\n###[<a name=\"map\"></a>map, mapSerial](#map)\n**\"map\"** maps over the given Array or Object asynchronously.  \nIf you pass an object it will be cloned to avoid modification.  \nThis function is curried so you may leave of the second parameter to delay execution.  \nThe value is passed as the first, the key/index as the second parameter.  \nIf the function returns a Promise the Promise will be resolved and the result will be used.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst double = value => Promise.resolve(value * 2);\n\nconst promise = cf.map(function* (number, index) {\n   const someAsyncValue = yield double(number);\n   return someAsyncValue;\n}, [2, 4]);\n\nconst promise2 = cf.map(function* (data, key) {\n   const someAsyncValue = yield double(data);\n   return someAsyncValue;\n}, { a: 2, b: 4});\n```\n\n**\"mapSerial\"** maps over the given Array or Object asynchronously but one after another.  \nIf you pass an object it will be cloned to avoid modification.  \nIf you want the highest possible speed you should not use this function but the completely asynchronous map function!  \nThat means your elements will get mapped over in order and the function will wait until something\nhas been returned by your function before continuing execution.  \n\nThis function is curried so you may leave of the second parameter to delay execution.  \nThe value is passed as the first, the key/index as the second parameter.  \nIf the function returns a Promise the Promise will be resolved and the result will be used.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst double = value => Promise.resolve(value * 2);\n\nconst promise = cf.mapSerial(function* (number, index) {\n   const someAsyncValue = yield double(number);\n   return someAsyncValue;\n}, [2, 4]);\n\nconst promise2 = cf.mapSerial(function* (data, key) {\n   const someAsyncValue = yield double(data);\n   return someAsyncValue;\n}, { a: 2, b: 4});\n```\n\n###[<a name=\"reduce\"></a>reduce](#reduce)\n**\"reduce\"** reduces the given Array using the given generator function asynchronously but one after another.  \nThat means your elements will get reduced in order and the function will wait until something\nhas been returned by your function before continuing execution.\n\nThe function is passed the accumulator as the first Parameter, the current value as the second value\nand the current Array index as the third parameter.\n\nThis function is curried so you may leave of any parameter to delay execution.  \nIf the function returns a Promise the Promise will be resolved and the result will be used.  \nIf the given function is a GeneratorFunction it will be wrapped with co.  \n\n```javascript\nconst asyncAddNumber = (a, b) => Promise.resolve(a + b);\nconst promise = cf.reduce(function* (accumulator, number, arrayIndex) {\n    return yield asyncAddNumber(number, accumulator);\n}, 10, [1, 2]);\n\npromise.then(result => console.log(result)); //13\n```\n\n## Tests\nTo execute the tests run\n```\nnpm test\n```\nin the main directory.\nIf you contribute new code make sure to include tests for your code!",
  "readmeFilename": "README.MD",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/N0ps32/co-functional.git"
  },
  "scripts": {
    "test": "mocha test/index.js"
  },
  "version": "0.2.1"
}
